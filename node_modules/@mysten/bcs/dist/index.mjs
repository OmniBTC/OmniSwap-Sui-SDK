// src/index.ts
import * as BN from "bn.js";

// src/b64.ts
function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function fromB64(sBase64, nBlocksSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);
  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return taBytes;
}
function uint6ToB64(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function toB64(aBytes) {
  var nMod3 = 2, sB64Enc = "";
  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {
      sB64Enc += "";
    }
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCodePoint(
        uint6ToB64(nUint24 >>> 18 & 63),
        uint6ToB64(nUint24 >>> 12 & 63),
        uint6ToB64(nUint24 >>> 6 & 63),
        uint6ToB64(nUint24 & 63)
      );
      nUint24 = 0;
    }
  }
  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
}

// src/hex.ts
function fromHEX(hexStr) {
  let intArr = hexStr.replace("0x", "").match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
  if (intArr === null) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHEX(bytes) {
  return bytes.reduce(
    (str, byte) => str + byte.toString(16).padStart(2, "0"),
    ""
  );
}

// src/index.ts
var BcsReader = class {
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return new BN.BN(value, 10);
  }
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return new BN.BN(value, 10);
  }
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return new BN.BN(value, 10);
  }
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return new BN.BN(result, 16);
  }
  read128() {
    let value1 = this.read64();
    let value2 = this.read64();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return new BN.BN(result, 16);
  }
  read256() {
    let value1 = this.read128();
    let value2 = this.read128();
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return new BN.BN(result, 16);
  }
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value;
  }
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i = 0; i < length; i++) {
      result.push(cb(this, i, length));
    }
    return result;
  }
};
var BcsWriter = class {
  constructor(size = 1024) {
    this.bytePosition = 0;
    this.dataView = new DataView(new ArrayBuffer(size));
  }
  static toBN(number) {
    switch (typeof number) {
      case "boolean":
        number = +number;
        return new BN.BN(number.toString());
      case "bigint":
        return new BN.BN(number.toString());
      default:
        return new BN.BN(number);
    }
  }
  shift(bytes) {
    this.bytePosition += bytes;
    return this;
  }
  write8(value) {
    this.dataView.setUint8(this.bytePosition, +BcsWriter.toBN(value));
    return this.shift(1);
  }
  write16(value) {
    this.dataView.setUint16(this.bytePosition, +BcsWriter.toBN(value), true);
    return this.shift(2);
  }
  write32(value) {
    this.dataView.setUint32(this.bytePosition, +BcsWriter.toBN(value), true);
    return this.shift(4);
  }
  write64(value) {
    BcsWriter.toBN(value).toArray("le", 8).forEach((el) => this.write8(el));
    return this;
  }
  write128(value) {
    BcsWriter.toBN(value).toArray("le", 16).forEach((el) => this.write8(el));
    return this;
  }
  write256(value) {
    BcsWriter.toBN(value).toArray("le", 32).forEach((el) => this.write8(el));
    return this;
  }
  writeULEB(value) {
    ulebEncode(value).forEach((el) => this.write8(el));
    return this;
  }
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));
    return this;
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.bytePosition; i++) {
      yield this.dataView.getUint8(i);
    }
    return this.toBytes();
  }
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}
var _BCS = class {
  constructor(schema) {
    this.types = /* @__PURE__ */ new Map();
    if (schema instanceof _BCS) {
      this.schema = schema.schema;
      this.types = new Map(schema.types);
      return;
    }
    this.schema = schema;
    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);
    this.registerVectorType(schema.vectorType);
    if (schema.types && schema.types.structs) {
      for (let name of Object.keys(schema.types.structs)) {
        this.registerStructType(name, schema.types.structs[name]);
      }
    }
    if (schema.types && schema.types.enums) {
      for (let name of Object.keys(schema.types.enums)) {
        this.registerEnumType(name, schema.types.enums[name]);
      }
    }
    if (schema.withPrimitives !== false) {
      registerPrimitives(this);
    }
  }
  ser(type, data, size = 1024) {
    let { typeName, typeParams } = this.parseTypeName(type);
    return this.getTypeInterface(typeName).encode(data, size, typeParams);
  }
  de(type, data, encoding) {
    if (typeof data == "string") {
      if (encoding) {
        data = decodeStr(data, encoding);
      } else {
        throw new Error("To pass a string to `bcs.de`, specify encoding");
      }
    }
    let { typeName, typeParams } = this.parseTypeName(type);
    return this.getTypeInterface(typeName).decode(data, typeParams);
  }
  hasType(type) {
    return this.types.has(type);
  }
  registerType(name, encodeCb, decodeCb, validateCb = () => true) {
    this.types.set(name, {
      encode(data, size = 1024, typeParams) {
        return this._encodeRaw(new BcsWriter(size), data, typeParams);
      },
      decode(data, typeParams) {
        return this._decodeRaw(new BcsReader(data), typeParams);
      },
      _encodeRaw(writer, data, typeParams) {
        if (validateCb(data)) {
          return encodeCb(writer, data, typeParams);
        } else {
          throw new Error(`Validation failed for type ${name}, data: ${data}`);
        }
      },
      _decodeRaw(reader, typeParams) {
        return decodeCb(reader, typeParams);
      }
    });
    return this;
  }
  registerAddressType(name, length, encoding = "hex") {
    switch (encoding) {
      case "base64":
        return this.registerType(
          name,
          (writer, data) => fromB64(data).reduce((writer2, el) => writer2.write8(el), writer),
          (reader) => toB64(reader.readBytes(length))
        );
      case "hex":
        return this.registerType(
          name,
          (writer, data) => fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer),
          (reader) => toHEX(reader.readBytes(length))
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  registerVectorType(name, elementType) {
    let { typeName, typeParams } = this.parseTypeName(name);
    if (typeParams.length > 1) {
      throw new Error("Vector can have only one type parameter; got " + name);
    }
    return this.registerType(
      typeName,
      (writer, data, typeParams2) => writer.writeVec(data, (writer2, el) => {
        let vectorType = elementType || typeParams2[0];
        if (!!vectorType) {
          let { typeName: typeName2, typeParams: typeParams3 } = this.parseTypeName(vectorType);
          return this.getTypeInterface(elementType || typeName2)._encodeRaw(writer2, el, typeParams3);
        } else {
          throw new Error(`Incorrect number of type parameters passed to vector '${typeName}'`);
        }
      }),
      (reader, typeParams2) => reader.readVec((reader2) => {
        let vectorType = elementType || typeParams2[0];
        if (!!vectorType) {
          let { typeName: typeName2, typeParams: typeParams3 } = this.parseTypeName(vectorType);
          return this.getTypeInterface(elementType || typeName2)._decodeRaw(reader2, typeParams3);
        } else {
          throw new Error(`Incorrect number of type parameters passed to vector '${typeName}'`);
        }
      })
    );
  }
  registerStructType(name, fields) {
    let struct = Object.freeze(fields);
    let canonicalOrder = Object.keys(struct);
    let { typeName, typeParams: structTypeParams } = this.parseTypeName(name);
    return this.registerType(
      typeName,
      (writer, data, typeParams) => {
        if (!data || data.constructor !== Object) {
          throw new Error(`Expected ${name} to be an Object, got: ${data}`);
        }
        for (let key of canonicalOrder) {
          if (key in data) {
            let paramIndex = structTypeParams.indexOf(struct[key]);
            let typeOrParam = paramIndex === -1 ? struct[key] : typeParams[paramIndex];
            {
              let { typeName: typeName2, typeParams: typeParams2 } = this.parseTypeName(typeOrParam);
              this.getTypeInterface(typeName2)._encodeRaw(writer, data[key], typeParams2);
            }
            ;
          } else {
            throw new Error(
              `Struct ${name} requires field ${key}:${struct[key]}`
            );
          }
        }
        return writer;
      },
      (reader, typeParams) => {
        let result = {};
        for (let key of canonicalOrder) {
          let paramIndex = structTypeParams.indexOf(struct[key]);
          let typeOrParam = paramIndex === -1 ? struct[key] : typeParams[paramIndex];
          {
            let { typeName: typeName2, typeParams: typeParams2 } = this.parseTypeName(typeOrParam);
            result[key] = this.getTypeInterface(typeName2)._decodeRaw(reader, typeParams2);
          }
          ;
        }
        return result;
      }
    );
  }
  registerEnumType(name, variants) {
    let struct = Object.freeze(variants);
    let canonicalOrder = Object.keys(struct);
    let { typeName, typeParams: canonicalTypeParams } = this.parseTypeName(name);
    return this.registerType(
      typeName,
      (writer, data, typeParams) => {
        if (data === void 0) {
          throw new Error(`Unable to write enum ${name}, missing data`);
        }
        let key = Object.keys(data)[0];
        if (key === void 0) {
          throw new Error(`Unknown invariant of the enum ${name}`);
        }
        let orderByte = canonicalOrder.indexOf(key);
        if (orderByte === -1) {
          throw new Error(
            `Unknown invariant of the enum ${name}, allowed values: ${canonicalOrder}`
          );
        }
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        writer.write8(orderByte);
        if (invariantType === null) {
          return writer;
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { typeName: typeName2, typeParams: typeParams2 } = this.parseTypeName(typeOrParam);
          return this.getTypeInterface(typeName2)._encodeRaw(writer, data[key], typeParams2);
        }
        ;
      },
      (reader, typeParams) => {
        let orderByte = reader.readULEB();
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        if (orderByte === -1) {
          throw new Error(
            `Decoding type mismatch, expected enum ${name} invariant index, received ${orderByte}`
          );
        }
        if (invariantType === null) {
          return { [invariant]: true };
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { typeName: typeName2, typeParams: typeParams2 } = this.parseTypeName(typeOrParam);
          return { [invariant]: this.getTypeInterface(typeName2)._decodeRaw(reader, typeParams2) };
        }
        ;
      }
    );
  }
  getTypeInterface(type) {
    let typeInterface = this.types.get(type);
    if (typeInterface === void 0) {
      throw new Error(`Type ${type} is not registered`);
    }
    return typeInterface;
  }
  parseTypeName(name) {
    let [left, right] = this.schema.genericSeparators || ["<", ">"];
    let l_bound = name.indexOf(left);
    let r_bound = Array.from(name).reverse().indexOf(right);
    if (l_bound === -1 && r_bound === -1) {
      return { typeName: name, typeParams: [] };
    }
    if (l_bound === -1 || r_bound === -1) {
      throw new Error(`Unclosed generic in name '${name}'`);
    }
    let typeName = name.slice(0, l_bound);
    let typeParams = name.slice(l_bound + 1, name.length - r_bound - 1).split(",").map((e) => e.trim());
    return { typeName, typeParams };
  }
};
var BCS = _BCS;
BCS.U8 = "u8";
BCS.U16 = "u16";
BCS.U32 = "u32";
BCS.U64 = "u64";
BCS.U128 = "u128";
BCS.U256 = "u256";
BCS.BOOL = "bool";
BCS.VECTOR = "vector";
BCS.ADDRESS = "address";
BCS.STRING = "string";
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base64":
      return toB64(data);
    case "hex":
      return toHEX(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function decodeStr(data, encoding) {
  switch (encoding) {
    case "base64":
      return fromB64(data);
    case "hex":
      return fromHEX(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function registerPrimitives(bcs) {
  bcs.registerType(
    BCS.U8,
    (writer, data) => writer.write8(data),
    (reader) => reader.read8(),
    (u8) => u8 < 256
  );
  bcs.registerType(
    BCS.U16,
    (writer, data) => writer.write16(data),
    (reader) => reader.read16(),
    (u16) => u16 < 65536
  );
  bcs.registerType(
    BCS.U32,
    (writer, data) => writer.write32(data),
    (reader) => reader.read32(),
    (u32) => u32 <= 4294967296
  );
  bcs.registerType(
    BCS.U64,
    (writer, data) => writer.write64(data),
    (reader) => reader.read64(),
    (_u64) => true
  );
  bcs.registerType(
    BCS.U128,
    (writer, data) => writer.write128(data),
    (reader) => reader.read128(),
    (_u128) => true
  );
  bcs.registerType(
    BCS.U256,
    (writer, data) => writer.write256(data),
    (reader) => reader.read256(),
    (_u256) => true
  );
  bcs.registerType(
    BCS.BOOL,
    (writer, data) => writer.write8(data),
    (reader) => reader.read8().toString(10) === "1",
    (_bool) => true
  );
  bcs.registerType(
    BCS.STRING,
    (writer, data) => writer.writeVec(
      Array.from(data),
      (writer2, el) => writer2.write8(el.charCodeAt(0))
    ),
    (reader) => {
      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(el)).join("");
    },
    (_str) => true
  );
}
function getRustConfig() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "Vec",
    addressLength: 20,
    addressEncoding: "hex"
  };
}
function getSuiMoveConfig() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: 20,
    addressEncoding: "hex"
  };
}
export {
  BCS,
  BcsReader,
  BcsWriter,
  decodeStr,
  encodeStr,
  fromB64,
  fromHEX,
  getRustConfig,
  getSuiMoveConfig,
  registerPrimitives,
  toB64,
  toHEX
};
//# sourceMappingURL=index.mjs.map